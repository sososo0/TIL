# 오늘의 학습 

- [문제 링크 - 프로그래머스 이모티콘 할인행사](https://school.programmers.co.kr/learn/courses/30/lessons/150368?language=java)

### 완전탐색 

- 주어진 문제는 완전탐색에 관련한 문제이다. 
- 문제를 풀 수 있는 방법은 2가지이다. 
  - 완전 탐색 + DFS 
  - 완전 탐색 + 비트마스킹 

### 오늘의 회고
  - 어떤 문제가 있었고, 나는 어떤 시도를 했는지 
    - 완전탐색과 관련한 문제를 풀었다.
    - 비트마스킹을 활용하여 문제를 풀었다. 
      - 10, 20, 30, 40으로 이루어진 할인률과 m개의 이모티콘을 효율적으로 매칭시키기 위해 

  - 어떻게 해결했는지 
    - 10, 20, 30, 40으로 이루어진 할인률과 m개의 이모티콘을 매칭시키고 이걸 사용자와 한명씩 비교하면서 정답을 찾아가는 것이 핵심이다.
    - DFS로 풀면 직관적으로 풀 수 있지만, 비트마스킹 방법이 더 먼저 떠올라 비트마스킹으로 풀었다. 
    - 비트마스킹을 이용한 방식은 다음과 같다. 
      - 우선, 할인율은 총 4개, 이모티콘은 최대 m개이다. 
      - 그럼 여기서 나올 수 있는 경우의 수는 4<sup>m</sup>이다. 
      - 그리고  4<sup>m</sup>을 비트마스킹으로 표현하면 `(1 << (2 * m))` 이다. 
        ```java
        int[] discounts = new int[m];
        int[] rates = {10, 20, 30, 40};

        // 위와 같이 이모티콘 할인 경우(discounts)와 할인율(rates)를 정했다.

        // 이렇게 for문을 설정하면 (0 ~ 4^m - 1)까지 총 4^m번 순회한다. 
        for (int mask = 0; mask < (1 << (2 * m)); mask++) { 

            for (int i = 0; i < m; i++) {
                // i번째의 할인율을 정한다. & 3 (& Ob11 과 같다.)을 해주는 이유는 2개의 비트가 필요하기 때문이다. 
                // 00, 01, 10, 11 으로 표현해야 rates를 탐색할 수 있기 때문이다.
                discounts[i] = rates[(mask >> (2 * i)) & 3]; 
            }
        }
        ```

  - 무엇을 새롭게 알았는지 
    - 비트마스킹을 이용해 할인율과 이모티콘을 매칭시키는 방법을 알게되었다.